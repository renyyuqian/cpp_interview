#### C++三大特性	

##### 封装

​			将数据与函数结合，形成类，其中数据和函数都是类的成员，目的在于将对象的使用者和设计者分开，可以隐藏实现细节（私有成员），增加代码模块的安全指数，提高可维护性和可修改性。

三个特点：

1. 结合性，即是将属性和方法结合
2. 信息隐蔽性，利用接口机制隐蔽内部实现细节，只留下接口给外界调用
3. 实现代码重用

##### 继承

​		从已有类产生新类的过程。 原有的类称为基类（父类），继承的类称为派生类（子类）。 可以创建子类对象来调用基类的方法和属性。

###### 继承方式

​		单一继承；多重继承； 菱形继承

##### 多态

​		“一个接口，多个方法”，用同一个接口，效果各不相同。 以继承和封装为基础，一个形态的多种表现形式。

###### 静态多态

​	重载： 函数重载和运算符重载 				类模板，函数模板。编译期

​	编译期。	函数重载，本质上就是模板的具现化。不需要共有基类，直接实现它们各自的定义。

###### 动态多态 

​	虚函数。子类的多态性，运行期。

​		运行期。子类继承父类（基类），基类中声明虚函数接口，子类重写这些虚函数。

#### 面向过程

​		分析除解决问题所需要的步骤，用函数把这些步骤一步一步实现，使用的时候依次调用。

优点：

​		性能比面向对象高（类调用需要实例化）。

缺点：

​		没有面向对象易维护，易复用，易扩展。

#### 面向对象

​		面向对象是把构成问题事务分解成各个对象。该对象实现这个问题的功能。 以功能来划分问题，而不是步骤。

#### struct  和 union

​		struct中每个成员都有自己独立的地址。

​		union是所有成员共享一段内存地址（成员中类型最大的长度）。 

 		struct和union都是由多个不同的数据类型成员组成, 但在任何同一时刻, union中只存放了一个被选中的成员, 而struct的所有成员都存在。

##### struct内存对齐

​		需要内存对齐的原因：CPU访问数据的效率问题。 例如，没有字节对齐，一个double类型的变量存储在1-9  那么计算机取这个数据会取两次。

​		默认按4字节对齐

#### **static 和const**

##### 		static

​				1、**局部变量**: 在局部变量之前加上关键字static，局部变量就被定义成为一个局部静态变量。

​										内存中的位置：data段; 局部的静态变量只能被初始化一次; 

​										作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域随之结束。

​		它就改变了局部变量的**存储位置**（从原来的栈中存放改为静态存储区）及其**生命周期**（局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问），但未改变其作用域。

​				2、**全局变量** : 在全局变量之前加上关键字static，全局变量就被定义成为一个全局静态变量。

​										  静态存储区（静态存储区在整个程序运行期间都存在）

​                                          未经初始化的全局静态变量会被程序自动初始化为0

​										  只能在本文件中存在和使用, 在声明他的文件之外是不可见的。

​					与非静态全局变量的区别：  两者的区别在于非静态全局变量的作用域是**整个源程序**， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。

​			  3、**函数**:  修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。

​			  4、**类**：  

​							成员变量： 用static修饰类的数据成员实际使其成为类的全局变量，会**被类的所有对象共享**，包括派生类的对象。因此，**static成员必须在类外进行初始化，而不能在构造函数内进行初始化。不过也可以用const修饰static数据成员在类内初始化**。

​							成员函数:  用static修饰成员函数，使这个类只存在这一份函数，所有对象共享该函数，不含this指针。 静态成员函数是可以独立访问的，也就是说，无须创建任何对象实例就可以访问。 **不可以同时用const和static修饰成员函数。**

##### 		**const**

​				const修饰变量： 限定变量为不可修改

​				const修饰指针： 指针常量和指针常量

​									指针常量： 指针指向可以修改， 指针指向的值不能修改 int const *p;  const int *p

​									常量指针：指针指向不可以修改，指针指向的值可以修改  int *const p;

​				const和函数

```
const int& fun(int& a); //修饰返回值
int& fun(const int& a); //修饰形参
int& fun(int& a) const{} //const成员函数
```

​				const和类:

​						1、 const修饰成员变量，在某个对象的声明周期内是常量，但是对于整个类而言是可以改变的。因为类可以创建多个对象，不同的对象其const成员变量的值是不同的。**不能在类内初始化const成员变量**，因为类的对象没创建前，编译器并不知道const成员变量是什么，因此const数据成员只能在初始化列表中初始化。		

​						2、 const修饰成员函数，主要目的是防止成员函数修改成员变量的值，即该成员函数并不能修改成员变量

​						3、 const对象，常对象，常对象只能调用常函数。				

​		static和const可以同时修饰成员函数吗?

​				不可以。const为了确保该函数不能修改类的实例的状态，会在函数中添加一个隐式的参数const this*。 但当一个成员为static的时候，该函数是没有this指针的。**static的作用是表示该函数只作用在类型的静态变量上，与类的实例没有关系；而const的作用是确保函数不能修改类的实例的状态**，与类型的静态变量没有关系。



#### **线程安全问题**

​		一个线程在初始化 m 的时候，其他线程执行到 m 的初始化这一行的时候，就会挂起而不是跳过。

#### **指针和引用的区别**

​			引用是变量的别名，它不能脱离被引用对象独立存在。 本质上是一个常量指针（指针的指向不可以修改，指向的值可以修改）

​			定义时必须初始化。

​			指针可以为空，引用不能为空， 指针利用取地址符返回指向改对象的地址，引用返回的是该对象的地址。

​		**指针传递**参数本质上是**值传递**的方式，它所传递的是一个地址值。 指针放的是实参变量地址的副本。引用传递传的是实参变量的地址。

​		sizeof 引用 得到的是所指向变量的大小，sizeof指针 表示指针本身的大小

#### #define宏常量和const常量的区别

​		**类型和安全检查不同**   #define 是字符替换, 没有类型检查   const 常量是常量的声明，编译时类型检查。   宏定义是一个"编译时"概念，在预处理阶段展开，不能对宏定义进行调试，生命周期结束与编译时期； const常量是一个"运行时"概念，在程序运行使用，放在内存中的data段中。

​		#define 不分配内存，存储在代码段中，const需要进行内存分配, 存储在数据段中。const常量可以在函数的参数列表中出现。

#### typedef与#define的区别

​		typedef**并不是定义一个新的类型而是给已有的类型起一个别名**   typedef有类型检查的功能  typedef有自己的作用域。

#### 左值和右值

##### 左值

​		存储在内存中、有明确存储地址（可寻址）的数据。 

​		左值是**可以取地址、位于赋值符号左边**的值，就记住，左值是表达式结束（不一定是赋值表达式）后依然存在的对象。

​		**特征：**

​				可通过取地址运算符获取其地址； 可修改的左值可以用来赋值； 可以用来初始化左值引用

##### 左值引用

​		左值引用分为：左值引用和常量左值引用(不希望被修改)

```c++
//左值引用
int a = 10;
int &b = a;  // 定义一个左值引用变量
b = 20;      // 通过左值引用修改引用内存的值
//常量左值引用
const int temp = 10; 
const int &var = temp;
```

##### 右值

​		那些可以提供数据值的表达式（不一定可以寻址，例如存储于寄存器中的数据）。右值有可能在内存中也有可能在寄存器中。一般来说就是活不过一行就会消失的值。

​		例如：非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和lambda表达式等都是纯右值。

##### **右值引用**

​		解决两个问题： 临时对象非必要的昂贵的拷贝操作； 在模板函数中如何按照参数的实际类型进行完美转发。

```c++
int i = getVar();
//这行代码会产生两种类型的值，一种是左值i，一种是函数getVar()返回的临时值，这个临时值在表达式结束后就销毁了，而左值i在表达式结束后仍然存在，这个临时值就是右值。

int j = 5;
auto f = []{return 5;};
//上面的代码中5是一个原始字面量， []{return 5;}是一个lambda表达式，都是属于纯右值，他们的特点是在表达式结束之后就销毁了。

T&& k = getVar();
//右值引用   这里，getVar()产生的临时值不会像第一行代码那样，在表达式结束之后就销毁了,而是会被“续命”，他的生命周期将会通过右值引用得以延续，和变量k的声明周期一样长。

特点：
　	通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去。让我们通过一个简单的例子来看看右值的生命周期。
　	
	右值引用独立于左值和右值。意思是右值引用类型的变量可能是左值也可能是右值。比如下面的例子：
		int&& var1 = 1;
	var1类型为右值引用，但var1本身是左值，因为具名变量都是左值。
	template <typename T> 
	T&& t在发生自动类型推断的时候，它是未定的引用类型，如果被一个左值初始化，它就是一个左值；如果它被一个右值初始化，它就是一个右值，它是左值还是右值取决于它的初始化。


T(T&& a) : m_val(val){ a.m_val=nullptr;} //移动构造函数 
//这行代码实际上来自于一个类的构造函数，构造函数的一个参数是一个右值引用。 解决问题：深拷贝时候， 临时对象非必要的昂贵的拷贝操作； 

// 移动语义
std::move方法来将左值转换为右值  move是将对象资源的所有权从一个对象转移到另一个对象，只是转移，没有内存的拷贝，这就是所谓的move语义。

//C++11之前调用模板函数时，存在一个比较头疼的问题，如何正确的传递参数。 
template <typename T>
void f(T&& val){ 
	foo(std::forward<T>(val)); 
}

//模板类会出现的问题
template <typename T>
void forwardValue(T& val)
{
    processValue(val); //右值参数会变成左值 
}
template <typename T>
void forwardValue(const T& val)
{
    processValue(val); //参数都变成常量左值引用了 
}
//C++11引入了完美转发：在函数模板中，完全依照模板的参数的类型（即保持参数的左值、右值特征），将参数传递给函数模板中调用的另外一个函数。C++11中的std::forward正是做这个事情的，他会按照参数的实际类型进行转发。
void processValue(int& a){ cout << "lvalue" << endl; }
void processValue(int&& a){ cout << "rvalue" << endl; }
template <typename T>
void forwardValue(T&& val)
{
    processValue(std::forward<T>(val)); //照参数本来的类型进行转发。
}
void Testdelcl()
{
    int i = 0;
    forwardValue(i); //传入左值 
    forwardValue(0);//传入右值 
}

输出：
lvaue 
rvalue
//右值引用T&&是一个未定的引用类型，可以接受左值或者右值，正是这个特性让他适合作为一个参数的路由，然后再通过std::forward按照参数的实际类型去匹配对应的重载函数，最终实现完美转发
```

**左值和右值区分的一个点**

​		从本质上理解，右值的创建和销毁由编译器幕后控制，程序员只能确保在本行代码有效的，就是右值(包括立即数)；而用户创建的，通过作用域规则可知其生存期的，就是左值(包括函数返回的局部变量的引用以及const对象)。

​		将亡值是与右值引用相关的表达式，比如，将要被移动的对象、T&&函数返回值、std::move返回值和转换为T&&的类型的转换函数的返回值等。



#### 深拷贝和浅拷贝

​		在未定义显示拷贝构造函数的情况下，系统会调用**默认的拷贝函数**——即浅拷贝，它能够完成成员的一一复制。

当数据成员中没有指针时，浅拷贝是可行的；

**但当数据成员中有指针时，会出问题。如果没有自定义拷贝构造函数，会调用默认拷贝构造函数，这样就会调用两次析构函数。**第一次析构函数delete了内存，第二次的就指针悬挂了。所以，此时，必须采用深拷贝。

深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。简而言之，当数据成员中有指针时，必须要用深拷贝。



#### 四种变量存储类型

##### **自动存储类**

​		auto存储类，即自动存储类。在函数内部定义的变量，如果不指定其存储类，那么它就是auto类变量。这个是最常见的，所以我们不加关键字auto

​		自动存储类在在进入代码块（函数）之前生成，在函数体内部存活，出了函数体（函数返回）后就消失。

​		自动变量默认初始值是不确定的、自动存储类每调用一次函数时都要赋一次初始值。

##### **静态存储类**

​		static关键字

##### **extern存储类**

​		如果在一个文件中要引用另一个文件中定义的外部变量，则在此文件中应用extern关键字把此变量说明为外部的。

```c++
extern int a; //a为别的文件中定义的外部变量
int mydata; //外部变量的定义 
extern int mydata;  //外部变量的说明 

大型程序为了易于维护和理解，通常需要把程序划分为多个文件来保存，每个文件都可以单独编译，最后再把多个文件的编译结果（即目标文件）连接到一起来生成一个可执行程序。这种情况下，如果在一个文件中需要引用另一个文件中的外部变量，就需要利用extern说明。
```

##### 寄存器存储类

​		为了提高某些自动类变量或函数参数的处理速度，可以在定义这些变量的类型说明符的前面加上register关键字，以通知编译系统为这些变量分配寄存器来存放其值。

#### this指针

​	this指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向**调用该非静态成员函数的那个对象。**

​	当对一个对象调用成员函数时，编译程序先将对象的地址赋给this指针。然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 `this` 指针。

​	this并不是一个常规变量，而是个右值，所以不能取得 `this` 的地址（不能 `&this`）。



##### this指针是什么时候创建的？

​		this在成员函数的开始执行前构造，在成员的执行结束后清除。**this指针只有在成员函数中才有定义。**我们无法知道一个对象的this指针的位置（只有在成员函数里才有this指针的位置）。当然，在成员函数里，你是可以知道this指针的位置的（可以通过&this获得），也可以直接使用它。

##### 在成员函数中调用delete this会出现什么问题？

​		在类对象的内存空间中，只有数据成员和虚函数表指针，类的成员函数单独放在代码段中。在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它。

​		当调用delete this时，类对象的内存空间被释放。在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。

##### 如果在类的析构函数中调用delete this，会发生什么？

​		会导致堆栈溢出。原因很简单，delete的本质是“为将被释放的内存调用一个或多个析构函数，然后，释放内存”。 显然，delete this会去调用本对象的析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出，系统崩溃。



#### inline 内联函数与宏定义

1. 相当于把内联函数里面的代码写在调用内联函数处。不用执行进入函数的步骤，直接执行函数体。

2. 从上面那一条的角度说，内联函数更像是宏，但却比宏多了类型检查，真正具有函数特性。

3. 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。

4. 编译器会为所用 inline 函数中的局部变量分配内存空间

5. 会将 inline 函数的输入参数和返回值映射到调用方法的局部变量空间中；

   - 优点

     ​	   内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。

     ​     内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。

     ​     内联函数在运行时可调试，而宏定义不可以。

     ​      可以说inline函数不仅吸收了了C宏定义的，同时消除宏定义的缺点。

     缺点

     ​	 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。

     ​     无法随着函数库升级而升级。inline函数的改变需要重新编译。万一又递归调用，代码量很大。

##### 虚函数（virtual）可以是内联函数（inline）吗？

​		 首先要明白，内联函数是编译器做出的选择，是否内联决定权在编译器，程序员不可控。同时，虚函数是多态性的一种体现，多态性表现在函数的运行阶段而不是函数的编译阶段。因此，**虚函数表现为多态性时（运行期）不可以内联。**

​		唯一可以内联的时候是：编译器知道所调用的对象是哪个类。**只有在编译器具有实际对象而不是对象的指针或引用时才会发生。**

#### explicit 关键字

​		explicit关键字主要是用来修饰类中的构造函数的，对于仅有一个参数或除第一个参数外其余参数均有默认值的类构造函数，尽可能使用explicit关键字修饰。        因为只有一个参数或者出了第一个参数其他参数是默认参数的构造函数来说，他还有另一个名字叫做转换构造函数。

​		所以**explicit主要用来防止隐式转换**      因为仅含一个参数的构造函数和除了第一个参数外其余参数都有默认值的多参构造函数承担了两个角色。 第一个是成为带参数的构造函数，第二个是一个默认且隐含的类型转换操作符（就是单参数的构造函数是一种隐含的类型转换符）

```cpp
//c++隐式类型转换是指c++自动将一种类型转换成另一种类型，是编译器的一种自主行为。
int i=3;
double j = 3.1;
i+j;//i会被转换成double类型，然后才做加法运算。

class A{};
class B: public A
{};//B是子类
void Fun(A& a);
B b;
Fun(b);//使用子类对象代替父类对象是可以的，也是因为隐式类型转换。

class Test
{
	public:
		Test(int i);
};

Test t1 = 1;//正确，由于强制类型转换，1先被Test构造函数构造成Test对象，然后才被赋值给t1
Test t2(1);//正确
```



#### friend友元类和友元函数

​		**友元函数**能够使得**普通函数直接访问类的保护数据和私有数据成员**，**避免了类成员函数的频繁调用**，可以**节约处理器开销**，提高程序的效率，但所矛盾的是，即使是最大限度大保护，同样也破坏了类的封装特性，这即是友元的缺点，在现在cpu速度越来越快的今天我们并不推荐使用它。

​		**友元类**的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）

​		友元的作用是提高了程序的运行效率（即**减少了类型检查和安全性检查等都需要时间开销**），但它破坏了**类的封装性和隐藏性**，使得非成员函数可以访问类的私有成员。



#### c++虚函数

##### 虚函数工作原理

​		c++没有强制规定虚函数的实现方式。**编译器中主要用虚表指针（vptr）和虚函数表（vtbl）来实现的**			![1735819539651](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1735819539651.png)

​     当调用一个对象对应的函数时，通过对象内存中的vptr找到一个虚函数表（注意这虚函数表既不在堆上，也不再栈上）。虚函数表内部是一个函数指针数组，记录的是该类各个虚函数的首地址。然后调用对象所拥有的函数。  

​	 当一个类在实现的时候，如果存在一个或以上的虚函数时，那么这个类便会包含一张虚函数表。而当一个子类继承并重写了基类的虚函数时，它也会有自己的一张虚函数表

##### 虚函数的性能分析

​		1、通过对象的vptr找到该类的vtbl，因为虚函数表指针是编译器加上去的，通过vptr找到vtbl就是指针的寻址而已。

​		2、找到对应vtbl中虚函数的指针，因为vtbl大部分是指针数组的形式实现的

​		在单继承的情况下调用虚函数所需的代价基本上和非虚函数效率一样，在大多数计算机上它多执行了很少的一些指令

​		在多继承的情况由于会根据多个父类生成多个vptr，在对象里为寻找 vptr 而进行的偏移量计算会变得复杂一些



##### 虚函数的一些问题

###### **构造函数可以设置为虚的吗？**

​		不能。因为虚函数的调用是需要通过“虚函数表”来进行的，而虚函数表也需要在对象实例化之后才能够进行调用。在构造对象的过程中，还没有为“虚函数表”分配内存。所以，这个调用也是违背先实例化后调用的准则。

​         子类的默认构造函数总要执行的操作：执行基类的代码后调用父类的构造函数。

###### **c++虚析构函数**

​		如果类是父类，则必须声明为虚析构函数。基类声明一个虚析构函数，为了确保释放派生对象时，按照正确的顺序调用析构函数。

​		如果析构函数不是虚的，那么编译器只会调用对应指针类型的虚构函数。切记，是指针类型的，不是指针指向类型的！而其他类的析构函数就不会被调用。例如如下代码：

```cpp
Employee* pe = new Singer;
delete pe;
//只会调用Employee的析构函数而不会调用Singer类的析构函数。如果这个类不是父类也可以定义虚析构函数，只是效率方面问题罢了
```

###### **那些函数不能是虚函数？**

​		友元函数，静态成员函数、内联函数、构造函数、

###### **虚函数表和虚函数指针的位置**

​		既不在堆上，也不在栈上。虚函数表（vtable）的表项在编译期已经确定，也就是一组常量函数指针。跟代码一样，在程序编译好的时候就保存在**可执行文件里面**。程序运行前直接加载到内存中即可。而堆和栈都是在运行时分配的。而跟虚函数表对应的，是虚函数表指针（vptr），作为对象的一个（隐藏的）成员，总是跟对象的其他成员一起。如果对象分配在堆上，vptr也跟着在堆上；如果对象分配在栈上，vptr也在栈上……

###### **编译器如何处理虚函数表**

对于派生类来说，编译器建立虚表的过程有三步：

1. 拷贝基类的虚函数表，如果是多继承，就拷贝每个基类的虚函数表
2. 查看派生类中是否有重写基类的虚函数，如果有，就替换成已经重写后的虚函数地址
3. 查看派生类中是否有新添加的虚函数，如果有，就加入到自身的虚函数表中

###### **构造函数或析构函数中调用虚函数会怎样？**

​		首先不应该在构造函数和析构函数中调用虚函数。

​		在构造函数中调用虚函数。假如有一个动物基类，这个基类定义了一个虚函数来表示动物的行为，叫做action。我们在基类的构造函数中调用这个虚函数。然后有一个派生类重写了该虚函数。当我们创建一个派生类对象的时候，首先会执行基类部分，因此执行基类的构造函数，然后才会执行子类的构造函数。编译器在执行基类构造函数中的虚函数时，会认为这是一个基类的对象，因为派生类还并没有构造出来。因此达不到动态绑定的效果，父类构造函数中调用的仍然是父类版本的函数，子类中调用的仍然是子类版本的函数

​		在析构函数中调用虚函数。析构函数也是一样，派生类先进行析构，如果有父类的析构函数中有virtual函数的话，派生类的内容已经被析构了，C++会视其基类，执行基类的virtual函数。



###### **如何获取 虚表地址和虚函数地址？**

```cpp
//该类如下：
class Base {
public:
    virtual void f() { cout << "Base::f" << endl; }
    virtual void g() { cout << "Base::g" << endl; }
    void h() { cout << "Base::h" << endl; }
};

Base b;
//  1.&b代表对象b的起始地址
//  2.(int *)&b 强转成int *类型,为了后面取b对象的前4个字节,前四个字节是虚表指针
//  3.*(int *)&b 取前四个字节,即vptr虚表地址
printf("虚表地址:%p\n", *(int *)&b);
//  根据上面的解析我们知道*(int *)&b是vptr,即虚表指针.并且虚表是存放虚函数指针的
//  所以虚表中每个元素(虚函数指针)在32位编译器下是4个字节,因此(int *)*(int *)&b
//  这样强转后为了后面的取四个字节.所以*(int *)*(int *)&b就是虚表的第一个元素.
printf("第一个虚函数地址:%p\n", *(int *)*(int *)&b);
printf("第二个虚函数地址:%p\n", *((int *)*(int *)(&b) + 1));
//始终记着vptr指向的是一块内存,
//  这块内存存放着虚函数地址,这块内存就是我们所说的虚表.
//64位下把int换成longlong就好了
```

#### 如何定义一个只能在堆上（栈上）生成对象的类?

##### 只能在堆上生成对象的类。

​		只能在堆上也就意味着不能再栈上，在栈上是编译器分配内存空间，构造函数来构造栈对象。在栈上当对象周期完成，编译器会调用析构函数来释放栈对象所占的空间，也就是说编译器管理了对象的整个生命周期。**编译器在调用构造函数为类的对象分配空间时，会先检查析构函数的访问性**，不光是析构函数，编译器会检查所有非静态函数的访问性。因此，如果类的析构函数是私有的，编译器不会为对象在栈上分配内存空间。

​	扩展一下，如果把析构函数写在private中的话，不能用A a这种静态方式建立对象。但也会有其他问题，如果这个类是父类的话，通常要将析构函数加上virtual关键字，然后再子类重写，实现多态性。但是子类不能访问private成员，可以使用protected，子类可以访问父类的protected成员，但不能访问private。

```cpp
class  A  
{  
protected :  
    A(){}  
    ~A(){}  
public :  
    static  A* create()  
    {  
        return  new  A();  
    }  
    void  destory()  
    {  
        delete  this ;  
    }  
};  
```

##### 只能在栈上生成对象的类。

​	只有使用new运算符才会在堆上创建对象。设为私有即可。

```cpp
class  A  
{  
private :  
    void * operator  new ( size_t  t){}      // 注意函数的第一个参数和返回值都是固定的   
    void  operator  delete ( void * ptr){}  // 重载了new就需要重载delete   
public :  
    A(){}  
    ~A(){}  
}; 
```

#### C++如何阻止类被实例化？

​	类中包含纯虚函数;       构造函数私有   把构造函数设置成私有，就不能在类的外部创建对象，相当于间接的阻止了该类实例化对象;                  



#### 调用拷贝构造函数时机

1. 对象以值传递的方式进入函数体
2. 对象以值传递的方式从函数返回
3. 一个对象需要另外一个对象初始化

##### 为什么拷贝构造函数必须是引用？

​	**为了防止递归调用。 **如果不用引用，就会是值传递的方式，但是值传递会调用拷贝构造函数生成临时对象，从而又调用一次拷贝构造函数。就这样无穷的递归下去。

#### 构造函数析构函数是否能抛出异常

​		**构造函数可以抛出异常**   对象只有在构造函数执行完成之后才算构造妥当，c++只会析构已经完成的对象。因此如果构造函数中发生异常，控制权就需要转移出构造函数，执行异常处理函数。在这个过程中系统会认为对象没有构造成功，导致不会调用析构函数。在构造函数中抛出异常会导致当前函数执行流程终止，在构造函数流程前构造的成员对象会被释放，但是如果在构造函数中申请了内存操作，则会造成内存泄漏。另外，如果有继承关系，派生类中的构造函数抛出异常，那么基类的构造函数和析构函数可以照常执行的。

​		**C++标准指明析构函数不能、也不应该抛出异常**  C++异常处理模型最大的特点和优势就是对C++中的面向对象提供了最强大的无缝支持。那么如果对象在运行期间出现了异常，C++异常处理模型有责任清除那些由于出现异常所导致的已经失效了的对象(也即对象超出了它原来的作用域)，并释放对象原来所分配的资源， 这就是调用这些对象的析构函数来完成释放资源的任务，所以从这个意义上说，析构函数已经变成了异常处理的一部分。

析构函数不能抛出异常原因有两个： 

1. 如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。
2. 异常发生时，c++的异常处理机制在异常的传播过程中会进行栈展开（stack-unwinding）。在栈展开的过程中就会调用已经在栈构造好的对象的析构函数来释放资源，此时若其他析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃。

```cpp
//解决办法：把异常完全封装在析构函数内部，决不让异常抛出函数之外，代码如下：
DBConn::~DBconn()
{
    try
    {
	    db.close(); 
    }
    catch(...)
    {
        abort();
    }
}
//如果close抛出异常就结束程序，通常调用abort完成：
```

#### 成员变量的初始化顺序问题

1. 成员变量在使用初始化列表初始化时，只与定义成员变量的顺序有关，与构造函数中初始化成员列表的顺序无关。因为成员变量的初始化次序是根据变量在内存中次序有关，而内存中的排列顺序早在编译期就根据变量的定义次序决定了。
2. 如果不使用初始化列表初始化，在构造函数内初始化时，此时与成员变量在构造函数中的位置有关。
3. 类成员在定义时，是不能初始化的
4. 类中const成员常量必须在构造函数初始化列表中初始化。
5. 类中static成员变量，必须在类外初始化。

##### **变量的初始化顺序：**

1. 初始化基类中的静态成员变量和静态代码块，按照在程序中出现的顺序初始化；
2. 初始化派生类中的静态成员变量和静态代码块，按照在程序中出现的顺序初始化；
3. 初始化基类的普通成员变量和代码块，再执行父类的构造方法；
4. 初始化派生的普通成员变量和代码块，在执行子类的构造方法；

#### public、private、protected继承特点

​		c++类中默认是私有继承

​		c++结构体中默认是public继承。

##### 什么不能被继承？

​	**构造函数**	 在创建派生类对象时必须调用派生类的构造函数。派生类构造函数通常使用成员列表初始化来调用基类构造函数以创建派生类中的基类部分。如果派生类没有使用成员列表初始化语法，则将使用默认的基类构造函数，如果基类没有默认的构造函数就会报错。             因为即使继承了，它的名字和派生类的名字也不一样（构造函数名字和类名一样），不能成为派生类的构造函数，当然更不能成为普通的成员函数。在设计派生类时，对继承过来的成员变量的初始化工作也要由派生类的构造函数完成，但是大部分基类都有private属性的成员变量，它们在派生类中无法访问，更不能使用派生类的构造函数来初始化。这种矛盾在C++继承中是普遍存在的，解决这个问题的思路是：**在派生类的构造函数中调用基类的构造函数**。

**析构函数** 析构函数不能被继承，释放对象的时候需要先调用派生类析构函数然后调用基类析构函数。

**赋值运算符=**  所以如果赋值运算符可以被继承，则会导致派生类也会有这个赋值运算符。参数可能不一样

**友元**   不能被继承



#### new/delete和malloc/free

都是用来申请动态内存和释放动态内存的

##### 区别

​		malloc/free是C++/C语言的标准**库函数**，而new/delete是C++的**运算符**。因此malloc仅仅只分配内存，而不会进行初始化类成员的工作，new不止分配内存，而且还是调用类的构造函数。

​		new操作符内存分配成功时候，返回的是对象类型的指针，不需要进行类型转换，从这个角度来说比较安全。 malloc内存分配成功则返回`void*`类型（泛型指针），必须通过强制类型转换将`void* `转换成需要的类型。

​		malloc失败，会返回空指针。 new失败，默认是抛出异常，要捕获异常`bad_alloc`

​		new操作符申请内存的时候不需要指定内存块的大小，编译器会自动根据类型信息来计算。 malloc需要显示的指出内存的大小



- 调用new 操作符分配对象时会经历三个步骤：

  1. 调用operator new函数分配一块足够大的，原始的空间
  2. 编译器运行相应的构造函数以构造对象，并传入初值
  3. 构造完对象后，就返回一个指向该对象的指针。

- 后续内存的分配

  当malloc分配内存后，发现后续内存分配不足的时候，可以使用realloc函数进行内存重载实现内存的扩充。realloc会先判断当前指针所指向的内存是否有足够的连续空间，如果有则可以原地扩大内存地址，并返回原来地址空间指针。如果空间不够，就从新分配一个空间，将原来的数据拷贝到新分配的内存区域，释放原来的内存区域。

##### free释放内存的理解

**空间的大小记录在参数指针指向地址的前面，free的时候通过这个记录即可知道要释放的内存有多大。**



#### 怎么再栈上分配内存

alloca函数

alloca函数分配的内存不需要手动释放，和普通的栈上对象的处理一样：超出作用域自动回收内存。



#### 四种强制类型转换

##### **static_cast**

​		用于基本数据类型之间的转换

​		void*和其他类型指针之间的转换

​		子类对象的指针转换成父类对象指针

​		以上三个都是隐式转换，最好吧所有隐式转换都用static_cast代替

##### **dynamic_cast**

​		只用于对象的指针和引用，主要用于执行“安全的向下转型”，因为downcast是不安全的

​		dynamic_cast是唯一一个在运行时处理的，因为我们转换后的指针如果请求一块无效的内存的话是会报错的，但是用该强转后会返回null，即转换成功会返回引用或者指针，失败返回null。如果一个引用类型执行了类型转换并且这个转换是不可能的，运行时一个`bad_cast`的异常类型会被抛出：

##### **const_cast**

​		const_cast转换符是用来移除const或volatile属性。一般用于强制消除对象的常量性。而*C*不提供消除*const*的机制（已验证）。

​		但是不能用于去除变量的常量性，而是去除指向对象的引用或指针的常量性，因此去除对象必须是指针或者引用

##### **reinterpret_cast**

​		这个操作符能够在非相关的类型之间转换。它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针。

​	  底层实现是从一个指针到别的指针的值的二进制拷贝。

##### 为什么要引入四种强制类型转换

​		c语言可以在任意类型之间进行转换，但是有一点就是不安全。可能会不经意间将指向const对象的指针转换成非const对象的指针，也有可能将基类对象指针转换成派生类对象的指针。因此这四种强制类型转换是的代码更加严谨规范

#### RAII基本理解与使用

​		RAII是c++中的一个惯用法，即“Resource Acquisition Is Initialization”，翻译为“资源获取就初始化”。是一种资源管理技术。c++之父说这种技术是依赖于类中构造函数和析构函数的性质以及与异常处理的交互性质来管理资源。

​		提出原因：**首先要明确在计算机系统中，资源的数量是有限的**，一定要合理管理和使用有限的资源。比如内存，文件，套接字等等吧。因此在使用资源的时候要遵循三个步骤：

1. 获取资源

2. 使用资源

3. 释放资源

   ​	总结：**在构造函数中申请分配资源，在析构函数中释放资源。因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定。**RAII的核心思想是将资源或者状态与对象的生命周期绑定，通过C++的语言机制，实现资源和状态的安全管理,智能指针是RAII最好的例子。

   RALL是c++区别于其他所有编程语言的重要特性。最初学习c++时的教条是new和delete一定要配套使用，但是使用RALL思想后，改成每一个资源配置动作都应该在单一语句执行，获得资源后立刻交给对象去管理，一般不要出现delete，用智能指针。

#### C++11新特性

##### **auto**

​	自动类型推导：   提高代码的可读性， 编译器可以根据初始值自动推导出类型。但是不能用于函数传参以及数组类型的推导。

##### **decltype**

`decltype`是为了解决复杂的类型声明而使用的关键字。

​		auto忽略顶层const，decltype保留顶层const；  对引用操作，auto推断出原有类型，decltype推断出引用；

对解引用操作，auto推断出原有类型，decltype推断出引用；  auto推断时会实际执行，decltype不会执行，只做分析。

​		**当你需要某个表达式的返回值类型而又不想实际执行它时用decltype**。

```cpp
int a=8, b=3;
auto c=a+b; //运行时需要实际执行a+b，哪怕编译时就能推导出类型
decltype(a+b) d; //编译期类型推导
//不可以用auto c; 直接声明变量，必须同时初始化。
```

##### c++智能指针

​	智能指针是一个`RAII`（`Resource Acquisition is initialization`）类模型，用来动态的分配内存。

​	把指针用类封装然后实例化成对象，在对象过期的时候，让析构函数删除指向的内存

​	它提供所有普通指针提供的接口，却很少发生异常。在构造中，它分配内存，当离开作用域时，它会自动释放已分配的内存。这样的话，程序员就从手动管理动态内存的繁杂任务中解放出来了。

###### 为什么要用智能指针？

原因1：内存泄露，即new和delete不匹配

原因2：多线程下对象析构问题，造成这个问题本质的原因是类对象自己销毁(析构)的时候无法对自己加锁,所以要独立出来,采用这个中间层(shared_ptr).

###### shared_ptr

共享所有权，也就是说多个指针可以指向一个相同的对象，当最后一个shared_ptr离开作用域的时候才会释放掉内存。

###### weak_ptr

`weak_ptr` 比较特殊，它主要是为了配合`shared_ptr`而存在的。就像它的名字一样，它本身是一个弱指针，因为它本身是不能直接调用原生指针的方法的。如果想要使用原生指针的方法，需要将其先转换为一个`shared_ptr`。那`weak_ptr`存在的意义到底是什么呢？

weak指针的出现是为了解决shared指针循环引用造成的内存泄漏的问题。

```cpp
//循环引用
struct A{
    shared_ptr<B> b;
};
struct B{
    shared_ptr<A> a;
};
shared_ptr<A> pa = make_shared<A>();
shared_ptr<B> pb = make_shared<B>();
pa->b = pb;
pb->a = pa;
//pa 和 pb 存在着循环引用，根据 shared_ptr 引用计数的原理，pa 和 pb 都无法被正常的释放，因为我们需要对方先释放。对于这种情况, 我们可以使weak_ptr：

expired() 判断所指向的原生指针是否被释放，如果被释放了返回 true，否则返回 false
use_count() 返回原生指针的引用计数
lock() 返回 shared_ptr，如果原生指针没有被释放，则返回一个非空的 shared_ptr，否则返回一个空的 shared_ptr
reset() 将本身置空
```

###### unique_ptr

​	`unique_ptr`的核心特点就如它的名字一样，它拥有对持有对象的唯一所有权。即两个`unique_ptr`不能同时指向同一个对象。

那具体这个唯一所有权如何体现呢？

1. `unique_ptr`不能被复制到另外一个`unique_ptr`
2. `unique_ptr`所持有的对象只能通过转移语义将所有权转移到另外一个`unique_ptr`

```c++
std::unique_ptr<A> a1(new A());
std::unique_ptr<A> a2 = a1;//编译报错，不允许复制
std::unique_ptr<A> a3 = std::move(a1);//可以转移所有权，所有权转义后a1不再拥有任何指针

std::unique_ptr<A> a1(new A());
A *origin_a = a1.get();//尽量不要暴露原生指针
std::unique_ptr<A> a2(a1.release());//常见用法，转义拥有权
a2.reset(new A());//释放并销毁原有对象，持有一个新对象
a2.reset();//释放并销毁原有对象，等同于下面的写法
a2 = nullptr;//释放并销毁原有对象
```

##### lambda表达式

​		我觉得lambda表达式的出现很简洁，也使得代码变得没那么膨胀吧

lambda 表达式定义了一个匿名函数，并且可以捕获一定范围内的变量。lambda 表达式的语法形式简单归纳如下

```cpp
[capture](params) opt -> ret {body;
捕获列表 [capture]
捕获一定范围内的变量，有以下几种方式：
	[] - 表示不捕捉任何变量
	[&] - 捕获外部作用域中所有变量，并作为引用在函数体内使用 (按引用捕获)
	[=] - 捕获外部作用域中所有变量，并作为副本在函数体内使用 (按值捕获)
	[=, &foo] - 按值捕获外部作用域中所有变量，并按照引用捕获外部变量 foo
	[this] - 捕获当前类中的 this 指针，让 lambda 表达式拥有和当前类成员函数同样的访问权限

参数列表 (params): 和普通函数的参数列表一样，如果没有参数参数列表可以省略不写
opt 选项，不需要可以省略，一般有两个
    mutable: 可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）
	exception: 指定函数抛出的异常，如抛出整数类型的异常，可以使用 throw ();
返回值类型
	很多时候，lambda 表达式的返回值是非常明显的，因此在 C++11 中允许省略 lambda 表达式的返回值。
函数体：函数的实现，这部分不能省略，但函数体可以为空。
```

##### nullptr和null的区别

```cpp
//首先给出NULL在C和C++中的定义
#ifdef __cplusplus  
#define NULL    0  
#else  
#define NULL    ((void *)0)  
#endif  
//要明白一点儿，NULL是一个无类型的东西，而且是一个宏。而宏这个东西，从C++诞生开始，就是C++之父嗤之以鼻的东西，他推崇尽量避免宏。


void f(void*){}
void f(int){}
int main()
{
    f(NULL); // what function will be called?
}
我们本来是想用NULL来代替空指针，但是在将NULL输入到函数中时，它却选择了int形参这个函数版本，所以是有问题的，这就是用NULL代替空指针在C++程序中的二义性。而引入了nullptr，这个问题就得到了真正解决，会很顺利的调到void f(void)这个版本。
//nullptr，可以保证在任何情况下都代表空指针
nullptr并非整型类别，甚至也不是指针类型，但是能转换成任意指针类型。nullptr的实际类型是std:nullptr_t。
```

##### **为什么用成员初始化列表会快一些？**

```cpp
/*
构造函数执行有两个阶段，首先是初始化阶段，这个阶段所有类中的成员都会被初始化，即使成员没有出现在初始化列表中。第二个阶段是计算阶段，一般是执行构造函数体内部的赋值操作。对于基本内置类型，没啥区别，所以不讨论。主要讨论的是类类型相关的问题。举个例子：
*/
class classA {...};
class classB
{
public:
    //赋值
    classB(classA a) {mA = a;}
    //成员列表初始化
    classB(classA a): mA(a) {}
private:
    classA mA;
};
对上述两个构造函数的实现来说，结果上是一样的，但在内部实现上有很大的区别。使用成员列表初始化的时候，直接调用的是A的拷贝构造函数完成。但是当赋值的时候，首先调用一次A的构造函数生成对象a，然后在调用一次A的构造函数生成对象mA，然后执行赋值构造函数。可以看到成员列表初始化的情况下少一次构造函数的调用，效率上肯定会提高。
```

##### function和bind

​	C++11的std::function和std::bind作用的对象叫做可调用对象，先解释一下什么是可调用对象c++中有几种可调用对象，比如函数、函数指针、lambda表达式、bind对象、函数对象。

​	函数指针就是指向函数的指针，把函数当做变量来处理，大部分用作回调函数

​	std::function对C++中各种可调用实体(普通函数、Lambda表达式、函数指针、以及其它函数对象等)的封装，形成一个新的可调用的std::function对象，简化调用。std::function对象是对C++中现有的可调用实体的一种类型安全的包裹(如：函数指针这类可调用实体，是类型不安全的)。

​	std::bind可以看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来适应原对象的参数列表。std::bind将可调用对象与其参数一起进行绑定，绑定后的结果可以使用std::function保存。std::bind主要有以下两个作用：

1. 将可调用对象和其参数绑定成一个仿函数；
2. 只绑定部分参数，减少可调用对象传入的参数。

std::bind的返回值是可调用实体，可以直接赋给std::function。

##### c++11关键字

**noexcept**告诉编译器指定某个函数不抛异常

```cpp

void swap(Type& x, Type& y) throw()   //C++11之前
{
    x.swap(y);
}
void swap(Type& x, Type& y) noexcept  //C++11
{
    x.swap(y);
}

```

**override**告诉编译器要重写父类的方法（函数参数、返回类型必须相同）

**final**    该关键字用来修饰类，当用final修饰后，该类不允许被继承，在 C++ 11 中 final 关键字要写在类名的后面。

**=default**   

​	如果一个 C++ 类没有显式地给出构造函数、析构函数、拷贝构造函数、operator = 这几类函数的实现，在需要它们时，编译器会自动生成；或者，在给出这些函数的声明时，如果没有给出其实现，编译器在链接时就会报错。=default 如果标记这类函数，编译器会给出默认实现。

**=delete**

禁止编译器生成这些函数

**using**  

一般的using关键子我们都是用来声明当前文件的命名空间，比如标准库的命名空间std-> using namespace std;

但在c++11中，它的用处还有几个 :

1. 取代typedef
2. 让父类同名函数在子类中以重载方式使用

##### 实现一个引用计数功能？c++中共享指针是怎样计数的？

###### **什么是引用计数？**

​		使用一个计数器来标识当前对象被多少指针所指或者被引用的次数。当引用对象被创建或被拷贝时，引用计数要加1；当引用对象被销毁或被覆盖时，引用计数减1；当引用计数为0时，数据对象被销毁。（也是核心原理）。通俗的来讲即这块地址上每多一个指针指向他，计数加一；

###### **实现引用计数的目的**		

​		右值引用---一旦一个对象通过调用new被分配出来，记录谁拥有这个对象是很重要的，因为其所有者要负责对它进行delete。但是对象所有者可以有多个，且所有权能够被传递，这就使得内存跟踪变得困难。引用计数可以跟踪对象所有权，并能够自动销毁对象。

​		节省内存，提高程序运行效率。如何很多对象有相同的值，为这多个相同的值存储多个副本是很浪费空间的，所以最好做法是让所有对象都共享同一个值的实现。

```cpp
template <class T>
class Ref_count{
private:
    T* ptr;         //数据对象指针
    int* count;     //引用计数器指针
public:
    /*
    普通指针构造共享指针,注意这样有问题，造成二龙治水
    因为同一块内存的普通指针构建的共享指针也指的是同一块内存，所以不应该是1，应该++
    比如shared_ptr<int> s_ptr(p);     s_ptr指向了这块地址，pCount = 1
    shared_ptr<int> s_ptr1 = s_ptr;  s_ptr1也指向了这块地址，pCount = 2
    shared_ptr<int> s_ptr2(p);       s_ptr2也指向了这块地址，不过重新创建了引用计数，pCount1 = 1，这样显然不行*/
    //所以要避免一个原生指针多次使用这个函数
    Ref_count(T* t):ptr(t),count(new int(1)){}
    
    
    ~Ref_count(){
        decrease();
    }

    //拷贝构造
    Ref_count(const Ref_count<T>& tmp){
        count = tmp->count;
        ptr = tmp->ptr
        increase();
    }

    //注意=在指针里面是指向的意思，因此说明=左边的共享指针指向了=右边的
    //因此=左边的共享指针-1，=右边的共享指针+1
    Ref_count<T>& operator=(const Ref_count& tmp){
        if(tmp != this){
            decrease();
            ptr = tmp->ptr;
            count = tmp->count;
            increase();
        }
        return *this
    }

    T* operator ->() const{
        return ptr;
    }

    T& operator *() const{
        return *ptr;
    }

    void increase(){
        if(count){
            *(count)++;
        }
    }

    void decrease(){
        if(count){
            *(count)--;
            if(*count == 0){
                //引用计数为0的时候就删除数据对象指针和引用对象指针
                delete ptr;
                ptr = nullptr;
                delete count;
                count = nullptr;
            }
        }
    }
    T* get() const{
        return ptr;
    }
    int get_count() const{
        if(!count){
            return 0;
        }
        return *count;
    }
};
```

##### volatile

​		当读取一个变量时，为提高存取速度，编译器优化时有时会先把变量读取到一个寄存器中；以后，再取变量值时，就直接从寄存器中取值。这个时候在寄存器和内存中都有我们的值，按道理来说应该是一致的，但有几种情况：

1. 当变量值在本线程里改变时，会同时把变量的新值copy到该寄存器中，以便保持一致

2. 当变量在因别的线程而改变了值，该寄存器的值不会相应改变，从而造成应用程序读取的值和实际的变量值不一致

3. 当该寄存器在因别的线程而改变了值，原变量的值不会改变，从而造成应用程序读取的值和实际的变量值不一致

   volatile的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的

**extern**是C/C++语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用。

##### 程序优化的方法

- 空间足够时，可以将经常需要读取的资源，缓存在内存中。
- 尽量减少大内存对象的构造与析构，考虑缓存暂时不用的对象，等待后续继续使用。
- 尽量使用C++11的右值语义，减少临时对象的构造。
- 简单的功能函数可以使用内联。少用继承，多用组合，尽量减少继承层级。
- 在循环遍历时，优化判断条件，减少循环次数。
- 优化线程或进程的同步方式，能用原子操作的就不用锁。能应用层同步的就不用内核对象同步。
- 优化堆内存的使用，如果有内存频繁的申请与释放，可以考虑内存池。
- 优化线程的使用，节省系统资源与切换造成的性能损耗，线程使用频繁的可以考虑线程池。
- 尽量使用事件通知，谨慎使用轮循或者sleep函数。
- 界面开发中，耗时的业务代码不要放在UI线程中执行，使用单独的线程去异步处理耗时业务，提高界面响应速度。
- 经常重构、优化代码结构。优化算法或者架构，从设计层面进行性能的优化。

##### RVO/NRVO机制

​	RVO (return value optimization) 和NRVO (named return value optimization) 是C++在处理 “返回一个class object的函数” 时常用的优化技术，主要作用就是消除临时对象的构造和析构成本。

​	RVO就是我经常自己写的那种，就是如果函数返回值有返回值，编译器会优化成传入一个引用，然后直接将值放在引用中：

```cpp
int get_max(){
    int a;
    return a;
}
//改成
int get_max(int& a){
    int a = max;
}
```

##### 静态链接和动态链接

###### 静态链接

​	  在程序的链接阶段，将上一阶段生成的test.o文件与库函数合并生成可执行文件。

​	   这样做好处就是以后的代码和库函数无关了，可以随便移植。

​		坏处是①静态链接的文件体积太大。②如果库函数更新的话需要重新链接。③在内存中会存在多分拷贝，因为每个程序都会存在一份库函数，如下图：

![1735991635379](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1735991635379.png)

###### 动态链接		

动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。

动态库在程序运行是才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。用户只需要更新动态库即可，增量更新。

![1735991740997](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1735991740997.png)

##### 指针没有初始化会怎么样

​	没有初始化的指针叫做野指针

​	指针未初始化能通过编译，但是运行的时候可能报错也可能不报错。因为你如果没使用这个指针，那倒是无所谓。但是如果你使用了，可能会出问题。因为这个指针由于没有初始化，可能会指向任何内存空间，完全随机的，有两种情况：

1. 指向的地址是系统使用的内存，用户程序不能使用，如果用户程序使用则会报错
2. 指向的不是系统的内存，不报错。但是如果这个指针指向了你之前程序使用过的内存，则你在个指针赋值，就会修改之前的内存上的数据，也会出问题。

指针变量设置为nullptr表明它不指向任何内容,这样引用她也不会出现上面的问题



#### 模板元编程

##### 模板底层怎么实现？

​	编译器并不是把函数模板处理成能够处理任意类的函数；

​	编译器从函数模板通过具体类型产生不同的函数；

​	编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，在调用的地⽅对参数替换后的代码进行编译。 这是因为函数模板要被实例化后才能成为真正的函数，在使用函数模板的源⽂件中包含函数模板的头文件，如果该头文件中只有声明，没有定义，那编译器⽆法实例化该模板，最终导致链接错误。

##### 函数模板

###### **调用方式（重要）**

1. 自动类型推导，隐式调用

   `mySwap(a, b)`

2. 显式指定类型

   `mySwap<int>(a, b)`

   1. 自动类型推导，必须推导出一致的数据类型T才可以使用。也就是说参数类型和你模板定义的得一致才行。
   2. 模板必须要确定出T的类型

###### **普通函数与模板函数的区别**

1. 普通函数调用时可以发生自动类型转换（隐式类型转换）
2. 如果使用函数模板，自动类型推导的话，则不会发生隐式转换
3. 如果使用函数模板，显式指定类型，则可以发生隐式转换

###### **调用规则**

1. 优先调用普通函数

2. 可以使用空模板参数来强制调用模板函数

   `myPrint<>(arg1, arg2,...)`

3. 函数模板也可以重载

4. 如果函数模板可以产生更好的匹配，优先调用函数模板

##### 类模板

###### 为什么成员函数模板不能是虚函数(virtual)？

​		这是因为c++ 编译器在解析一个类的时候就要确定虚函数表的大小，如果允许一个虚函数是模板函数，那么compiler就需要在parse这个类之前扫描所有的代码，找出这个模板成员函数的调用（实例化），然后才能确定vtable的大小，而显然这是不可行的，除非改变当前compiler的工作机制。因为类模板中的成员函数在调用的时候才会创建

###### **类模板中成员函数创建时间：**

1. 普通类中的成员函数在编译的时候就创建
2. 类模板中的成员函数在调用的时候才会创建

###### **类模板与继承**

```cpp
//当派生类继承基类的一个类模板时，子类在声明时，要指定出分类中的T类型
template<class T>
class Father{
    T m;
};
//报错
class Son: public Father{
    
}; 
//正确
class Son: public Father<int>{
    
}; 
//因为子类要继承父类中的成员变量，但是模板没有指定内存大小，所以是不确定的，而不确定性是c++所嗤之以鼻的。因此继承的时候得指定要继承模板的数据类型才行。

//如果不指定，编译器无法给子类非配内存
//如果要灵活的话，子类也需变为类模板
template<class T1, class T2>
class Son: public Father<T2>{
    T1 obj;
}; 
```

###### **类模板成员函数的类外实现**

```cpp
//构造函数类外实现
template<class T1, class T2>
Person<T1, T2>::Person(T1 name, T2 age){}

//成员函数类外实现
template<class T1, class T2>
void Person<T1, T2>::show(){}
```

###### 模板和实现可不可以不写在一个文件里面？为什么？

​		不可以。

​		模板定义很特殊。由template<…>处理的任何东西都意味着编译器在当时不为它分配存储空间，它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。

###### 模板和继承，这个区别是什么？

**第一点：**

模板可以生成一组类或者函数，这些类或函数的实现都是一样的

继承是事物之间的一种关系，从父类到子类实际上就是从普遍到特殊、从共性到特性

**第二点：**

模板和继承都是多态性的体现，继承是运行时的多态性，模板是编译时的多态性。

**第三点：**

继承是数据的复制、模版是代码的复制。

模板函数在编译完成之后，会生成对应参数数类型的函数；

继承是对虚表、数据的复制

#### c++RITT机制

​		RTTI(Run Time Type Identification)即通过运行时类型识别，C++引入这个机制是为了让程序在运行时能根据基类的指针或引用来获得该指针或引用所指的对象的实际类型。但是现在RTTI的类型识别已经不限于此了，它还能通过typeid操作符识别出所有的基本类型（int，指针等）的变量对应的类型。

#### 虚继承

##### **为什么要引入虚拟继承**

​		虚拟继承是多重继承中特有的概念。虚拟基类是为解决多重继承而出现的。如:类D继承自类B1、B2，而类B1、B2都继承自类A，因此在类D中两次出现类A中的变量和函数。 数据会出现二义性。

##### **引入虚继承和直接继承会有什么区别呢**





#### c++出现的内存问题

1. 缓冲区溢出。一般来说vector或者string都很智能帮我们管理缓冲区，所以很多时候不会出现
2. 指针悬挂/野指针，用shared_ptr和weak_ptr就可以解决
3. 重复释放，用boost的scoped_ptr或者仔细检查，只在对象析构的时候释放一次
4. 内存泄漏，也可以用scoped_ptr，这个比其他的来说还算正常，至少用一段时间内感觉不出来
5. new[]和delete不配对，moduo书中给的方案是把new[]统统换成vector就行
6. 内存碎片，这个就非常深邃了

#### C++异常处理的方法

C++中的异常处理机制主要使用**try**、**throw**和**catch**三个关键字。就是程序中需要throw一个类型的异常，然后catch住这个类型的异常进行处理。

程序的执行流程是先执行try包裹的语句块，如果执行过程中没有异常发生，则不会进入任何catch包裹的语句块，如果发生异常，则使用throw进行异常抛出，再由catch进行捕获，throw可以抛出各种数据类型的信息，代码中使用的是数字，也可以自定义异常class。

#### 怎样判断两个浮点数是否相等？

对两个浮点数判断大小和是否相等不能直接用==来判断，会出错！明明相等的两个数比较反而是不相等！对于两个浮点数比较只能通过相减并与预先设定的精度比较，记得要取绝对值！浮点数与0的比较也应该注意。与浮点数的表示方式有关

#### STL

Standard Template Library，标准模板库，是C++的标准库之一，一套基于模板的容器类库，还包括许多常用的算法，提高了程序开发效率和复用性。

##### **STL包含6大部件**

- 容器：容纳一组元素的对象，提供各种数据结构。
- 迭代器：提供一种访问容器中每个元素的方法，从实现的角度来说，迭代器是一种将`operator*`, `operator->`, `operator++`等指针操作赋予 重载的类模板。
- 仿函数：一个行为类似函数的对象，调用它就像调用函数一样，重载了`operator()`的类或者类模板。
- 算法：包括查找算法、排序算法等。
- 适配器：用来修饰容器等，比如queue和stack，底层借助了deque。
- 空间配置器：负责空间配置和管理，是一个实现了动态空间配置，空间管理，空间释放的类模板。

##### vector

vector是动态空间，随着元素的加入它内部机制会自行扩充空间以容纳新元素。vector维护了一个连续的线性空间，普通指针就可以满足要求作为vector的迭代器，随机访问迭代器。

###### vector的底层原理

vector底层是一个**动态数组**，包含三个迭代器，start和finish之间是已经被使用的空间范围，end_of_storage是整块连续空间包括备用空间的尾部。如图：

![1735994268096](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1735994268096.png)

###### vector内存增长机制

​			**当空间不够装下数据（vec.push_back(val)）时，会自动申请另一片更大的空间（1.5倍或者2倍），然后把原来的数据拷贝到新的内存空间，接着释放原来的那片空间**(gcc是2倍，vs下的mingw是1.5倍)

​			当释放或者删除（vec.clear()）里面的数据时，其存储空间不释放，仅仅是清空了里面的数据。

​			因此，对vector的任何操作一旦引起了空间的重新配置，指向原vector的所有迭代器会都失效了

###### reserve和resize的区别

​			reserve增加了vector的capacity，但是它的size没有改变！而resize改变了vector的capacity同时也增加了它的size！

​			reserve是容器预留空间，但在空间内不真正创建元素对象，所以在没有添加新的对象之前，不能引用容器内的元素。加入新的元素时，要调用push_back()/insert()函数

​	      resize是改变容器的大小，且在创建对象，因此，调用这个函数之后，就可以引用容器内的对象了，因此当加入新的元素时，用operator[]操作符，或者用迭代器来引用元素对象。此时再**调用push_back()函数，是加在这个新的空间后面的。**

​		 reserve就是预留内存。为的是避免内存重新申请以及容器内对象的拷贝

###### vector中size()和capacity()的区别

​		size()指容器当前拥有的元素个数（对应的resize(size_type)会在容器尾添加或删除一些元素，来调整容器中实际的内容，使容器达到指定的大小。

​		capacity()指容器在必须分配存储空间之前可以存储的元素总数。



无论你的定义是： `vector<int*> *p = new vector<int*>`; 还是 `vector<int*> p` 其元素都是在堆上进行分配。

C++语言中，所有`new`和`malloc`创建的变量均存放在堆区，这已经是一个共识。但是鲜为人知的是，STL库中的容器虽没有经过这两个关键字创建，但同样是存放在堆区。这与动态数组性质相同。如果从汇编角度观察便会发现，容器均调用了`allocator`来创建。



###### emplace_back和push_back

**相同**

emplace_back和push_back都支持左值和右值的传入。

我们这里就说类元素，不说内置和基本类型了。

传入左值的时候，会调用拷贝构造函数构造出一个匿名对象，然后将该对象存储到vector中

传入右值的时候，调用的是两个函数的移动构造函数构。

**不同**

emplace_back 还支持另一种调用方式，原地构造（in-place construction）！

即emplace_back的参数是可变的，传入的参数可以是vector类型的构造函数的参数，直接原地构造

比如emplace_back(10, “test”)可以只调用一次constructor

而push_back(MyClass(10, “test”))中MyClass(10, “test”)调用了一次构造函数，同时值传递又调用拷贝构造函数。



vector的内存占用空间只增不减，比如你首先分配了10,000个字节，然后erase掉后面9,999个，留下一个有效元素，但是内存占用仍为10,000个。

**所有的内存空间是在vector析构时候才能被系统回收。**

empty()用来检测容器是否为空的，clear()可以清空所有元素。但是即使clear()，vector所占用的内存空间依然如故，无法保证内存的回收。

如果需要空间动态缩小，可以考虑使用deque。如果vector，可以用swap()来帮助你释放内存。

##### deque

功能
·双端数组，可以对头端进行插入删除操作

###### deque与vector区别：

·vector对于头部的插入删除效率低，数据量越大，效率越低
·deque相对而言，对头部的插入删除速度会比vector快
·vector访问元素时的速度会比deque快，这和两者内部实现有关

###### deque内部工作原理

deque内部有个中控器，维护每段缓冲区的内容，缓冲区中存放真实数据
中控器维护的是每个缓冲区地址，使得使用deque时像一片连续的内存空间

deque容器得迭代器是支持随机访问得迭代器



##### list

链表容器：
**功能**：将数据进行链式存储
链表是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的
链表的组成：链表由一系统结点组成
结点的组成：一个是存储数据元素的数据域，另一个是存储下一个节点地址的指针域
STL中的链表是双向循环链表

list的随机存取非常没有效率，时间复杂度为o(n);

list是一个双链表结构，支持对链表的双向遍历。每个节点包括三个信息：元素本身，指向前一个元素的节点（prev）和指向下一个元素的节点（next）。因此list可以高效率的对数据元素任意位置进行访问和插入删除等操作。由于涉及对额外指针的维护，所以开销比较大。

##### stack

​	是⼀种先进后出的数据结构，只有⼀个出口，stack 允许从最顶端新增元素，移除最顶端元素，取得最顶端元素。 deque 是双向开口的数据结构，所以使⽤ deque 作为底部结构并封闭其头端开口，就形成了⼀个 stack。



##### map和set为什么用红黑树

高度越小越好，BST这种有特殊情况，比如只有左子树有值，导致O(n)复杂度

AVL树平衡有点太变态了，导致每次自适应的时候效率低一点。所以综合来说红黑树是最优秀的

##### 算法

stable_sort (first, last)和sort() 函数功能相似，不同之处在于该函数不会改变它们的相对位置。

stable_sort() 函数是基于归并排序实现的。

sort() 函数是基于快速排序实现的。



##### STL容器是线程安全的吗？

众所周知，STL容器不是线程安全的。对于vector，即使写方（生产者）是单线程写入，但是并发读的时候，由于潜在的内存重新申请和对象复制问题，会导致读方（消费者）的迭代器失效。