

### Mysql执行流程

![1736247511892](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736247511892.png)

Server层：  		负责建立链接，分析和执行SQL

​			大多数的核心功能都在此层实现，例如连接器，查询缓存，预处理器，解析器，优化器，执行器等

内置函数（日期，时间等）和跨存储引擎的功能（存储过程，触发器，视图）

​			**连接器**： 负责连接Mysqld服务器，TCP三次握手 	show processlist 查看被多少个客户端连接

​			**查询缓存：**以Key-Value存储，Key：查询语句，Value：查询值，只有select才会看查询缓存。MySQL 8.0 已删除该模块；

​			**解析器：** 做两件事：   词法分析：识别关键字   		语法分析： 判断SQL语法是否正常，正常则构建语法树， 方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等。

​			**执行SQL**： 三个阶段

**预处理阶段**：检查表或字段是否存在；将 `select *` 中的 `*` 符号扩展为表上的所有列

**优化阶段**： 将SQL查询语句的执行方案确定下来。比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。（explain）

**执行阶段**：执行器会和存储引擎交互，交互是以记录为单位的。

​			主键索引查询、全盘扫描、索引下推。 

什么是索引下推？

​			能够减少**二级索引**在查询时的回表操作，提高查询的效率。因为它将 Server 层部分负责的事情，交给存储引擎层去处理了。   Extr 部分显示了 “Using index condition”，说明使用了索引下推。

存储引擎：   负责数据的存储和读取。   

​			有多个存储引擎（InnoDB、MyISAM、Memory）等。  不同的存储引擎共用一个Server层。

### 一条记录是怎么存储的

#####  MySQL 的数据存放在哪个文件？

​		MySQL的数据都是存放在磁盘的。存储的行为是由存储引擎实现的，MySQL 支持多种存储引擎，不同的存储引擎保存的文件自然也不同。

​		每创建一个 database（数据库） 都会在/var/lib/mysql/ 目录里面创建一个以 database为名的目录，然后保存表结构和表数据的文件都会存放在这个目录里。

​		**db.opt:**    用来存储当前数据库的默认字符集和字符校验规则。

​		**表名.frm**： 用来保存每个表的元数据信息的，主要包含表结构定义。

​		**表名.ibd**：  每一张表的数据都存放在一个独立的 .ibd 文件。这个文件也称为独占表空间文件。

##### 表空间文件的结构是怎么样的？

​		**表空间由段（segment）、区（extent）、页（page）、行（row）组成**，InnoDB存储引擎的逻辑存储结构大致如下图：

![1736249248005](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736249248005.png)

**行：** 数据库表中的记录都是按行（row）进行存放的，每行记录根据不同的行格式，有不同的存储结构。

**页：**记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I/O 操作）只能处理一行数据，效率会非常低。**InnoDB 的数据是按「页」为单位来读写的**，当需要读一条记录的时候，并不是将这个行记录从磁盘读出来，而是以页为单位，将其整体读入内存。**默认每个页的大小为 16KB**。页是 InnoDB 存储引擎磁盘管理的**最小单元**。

**区**：  目的：让链表中相邻的页的物理位置也相邻。在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了， **而是按照区（extent）为单位分配。** **每个区的大小为 1MB，对于 16KB 的页来说**。 

**段**：表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。段一般分为数据段、索引段和回滚段等。

​		索引段：存放 B + 树的非叶子节点的区的集合；

​		数据段：存放 B + 树的叶子节点的区的集合；

​		回滚段：存放的是回滚数据的区的集合；

#####  InnoDB 行格式有哪些？

​		行格式（row_format），就是一条记录的存储结构。

​		InnoDB 提供了 4 种行格式，分别是Redundant、Compact、Dynamic和 Compressed 行格式。

**Compact**

![1736249690658](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736249690658.png)

一条完整的记录分为「记录的额外信息」和「记录的真实数据」两个部分。

**记录的额外信息**:  记录的额外信息包含 3 个部分：变长字段长度列表、NULL 值列表、记录头信息。

![1736249934725](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736249934725.png)

逆序存放为了 提高Cache 命中率  NULL 值列表也不是必须的。 变长字段长度列表 都不是必须的。

##### 行溢出后，MySQL 是怎么处理的？

​		一页只能存 16KB，如果一些大对象如 TEXT、BLOB 可能存储更多的数据，这时一个页可能就存不了一条记录。这个时候就会**发生行溢出，多的数据就会存到另外的「溢出页」中**。

![1736250214253](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736250214253.png)

Compressed 和 Dynamic 这两个行格式和 Compact 非常类似， 主要的区别在于处理行溢出数据时有些区别。

### 索引

##### InnoDB 是如何存储数据的？

​		按行存，**按「数据页」为单位来读写的**，数据库的 I/O 操作的最小单位是页。 每个数据页用双向链表的形式组织起来。

​		**数据页中的记录按照「主键」顺序组成单向链表**，单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。

​		数据页中有一个**页目录**，起到记录的索引作用，就像我们书那样，针对书中内容的每个章节设立了一个目录，想看某个章节的时候，可以查看目录，快速找到对应的章节的页数，而数据页中的页目录就是为了能快速找到记录。

![1736250744367](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736250744367.png)

​		**页目录就是由多个槽组成的，槽相当于分组记录的索引**。

##### B+ 树是如何进行查询的？

​		InnoDB 里的 B+ 树中的**每个节点都是一个数据页**，结构示意图如下：

![1736250976944](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736250976944.png)

- 只有叶子节点（最底层的节点）才存放了数据，非叶子节点（其他上层节）仅用来存放目录项作为索引。
- 非叶子节点分为不同层次，通过分层来降低每一层的搜索量；

- 所有节点按照索引键大小排序，构成一个双向链表，便于范围查询；

##### 聚簇索引和二级索引

索引又可以分成聚簇索引和非聚簇索引（二级索引），它们区别就在于叶子节点存放的是什么数据：

​	**聚簇索引**的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚簇索引的叶子节点。 只能有一个

​    **二级索引**的叶子节点存放的是主键值，而不是实际数据。

InnoDB 在创建聚簇索引时，会根据不同的场景选择不同的列作为索引：

​	·如果有主键，默认会使用主键作为聚簇索引的索引键

​	·如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键

​	·在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键

二级索引的 B+ 树如下图，数据部分为主键值：

![1736251442099](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736251442099.png)

![1736251470857](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736251470857.png)

##### B+ 树与 B 树差异

​			叶子节点（最底部的节点）才会存放实际数据（索引+记录），非叶子节点只会存放索引

​			所有索引都会在叶子节点出现，叶子节点之间构成一个有序链表

​			非叶子节点的索引也会同时存在在子节点中，并且是在子节点中所有索引的最大（或最小）

​			非叶子节点中有多少个子节点，就有多少个索引。

![1736251983914](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736251983914.png)

![1736252066431](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736252066431.png)

#### 索引失效

###### 对索引使用左或者左右模糊匹配

​		当我们使用左或者左右模糊匹配的时候，也就是 **like %xx**` 或者 `**like %xx%**这两种方式都会造成索引失效。

###### 对索引使用函数

​		如果查询条件中对索引字段使用函数，就会导致索引失效。 

​		select * from t_user where length(name)=6;

​		因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。

###### 对索引进行表达式计算

​		在查询条件中对索引进行表达式计算，也是无法走索引的。

​		explain select * from t_user where id + 1 = 10;

###### 对索引隐式类型转换

​		如果索引字段是字符串类型，但是在条件查询中，输入的参数是整型的话，你会在执行计划的结果发现这条语句会走全表扫描。

​		select * from t_user where phone = 1300000001;

​		但是如果索引字段是整型类型，查询条件中的输入参数即使字符串，是不会导致索引失效，还是可以走索引扫描。

![1736252990652](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736252990652.png)

**MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较**。

###### 联合索引非最左匹配

​		**多个普通字段组合在一起创建的索引就叫做联合索引**，也叫组合索引。

​		创建联合索引时，我们需要注意创建时的顺序问题，因为联合索引 (a, b, c) 和 (c, b, a) 在使用的时候会存在差别。需要遵循**最左匹配原则**



索引下推的大概原理是：截断的字段不会在 Server 层进行条件判断，而是会被下推到「存储引擎层」进行条件判断（因为 c 字段的值是在 `(a, b, c)` 联合索引里的），然后过滤出符合条件的数据后再返回给 Server 层。由于在引擎层就过滤掉大量的数据，无需再回表读取数据来进行判断，减少回表次数，从而提升了性能。

###### WHERE 子句中的 OR

​		在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。

##### 什么时候需要 / 不需要创建索引？

###### 什么时候需要创建索引？

​	字段有唯一性限制的，比如商品编码；

​	经常用于 `WHERE` 查询条件的字段，这样能够提高整个表的查询速度；

​	经常用于 `GROUP BY` 和 `ORDER BY` 的字段，这样在查询的时候就不需要再去做一次排序了

###### 什么时候不需要创建索引？

​	`WHERE` 条件，`GROUP BY`，`ORDER BY` 里用不到的字段。

​	字段中存在大量重复数据，不需要创建索引，比如性别字段；

​	表数据太少的时候，不需要创建索引；

​	经常更新的字段不用创建索引，比如不要对电商项目的用户余额建立索引。

​		

##### count(*) 和 count(1) 有什么区别？

​		count() 是一个聚合函数，函数的参数不仅可以是字段名，也可以是其他任意表达式，该函数作用是**统计符合查询条件的记录中，函数指定的参数不为 NULL 的记录有多少个**。

### 事务

##### 事务有哪些特性？

​	**原子性（Atomicity）**：事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。

​	**一致性（Consistency）**：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。

​	**隔离性（Isolation）**：数据库允许多个并发事务同时对其数据进行读写和修改的能力。

​	**持久性（Durability）**：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

持久性是通过 redo log （重做日志）来保证的； 原子性是通过 undo log（回滚日志） 来保证的； 隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的； 一致性则是通过持久性+原子性+隔离性来保证。



##### 并行事务会引发什么问题？

​		**脏读**     如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象。

​		**不可重复读**   在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。

​		**幻读**     在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象。

​		![1736254928706](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736254928706.png)

![1736254949350](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736254949350.png)

##### 事务的隔离级别有哪些？

​		四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低，这四个隔离级别如下：

**读未提交（RU）**   指一个事务还没提交时，它做的变更就能被其他事务看到；

**读提交（RC）**  指一个事务提交之后，它做的变更才能被其他事务看到；

**可重复读（RR）**  指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，																												**MySQL InnoDB 引擎的默认隔离级别**；

**串行化（serializable ）**   会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；

![1736255082963](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736255082963.png)

##### 这四种隔离级别具体是如何实现的呢？

![1736255295150](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736255295150.png)

##### Read View

![1736255393073](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736255393073.png)

###### 四个重要的字段

​		**m_ids:**  指的是在创建 Read View 时，当前数据库中「活跃事务」的**事务 id 列表**，注意是一个列表，**“活跃事务”**指的就是，启动了但还没提交的事务。

​		**min_trx_id ：**  指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 **id 最小的事务**，也就是 m_ids 的最小值。

​		**max_trx_id：**  这个并不是 m_ids 的最大值，而是**创建 Read View 时当前数据库中应该给下一个事务的 id 值** ，也就是全局事务中最大的事务 id 值 + 1；

​		**creator_trx_id** ： 指的是**创建该 Read View 的事务的事务 id**。

###### 聚簇索引记录中的两个隐藏列

​       **trx_id：**  当一个事务对某条聚簇索引记录进行改动时，就会**把该事务的事务 id 记录在 trx_id 隐藏列里**；

​	  **roll_pointer：**  每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后**这个隐藏列是个指针，指向每一个旧版本记录**，于是就可以通过它找到修改前的记录。

在创建 Read View 后，我们可以将记录中的 trx_id 划分这三种情况：

![1736255665736](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736255665736.png)

![1736255827972](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736255827972.png)

**这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）**



##### 可重复读是如何工作的？

​		可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View。

##### 读提交是如何工作的？

​	   读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View。

​		也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。

##### 快照读是如何避免幻读的？、

​		可重复读隔离级是由 MVCC（多版本并发控制）实现的，实现的方式是开始事务后（执行 begin 语句后），在执行第一个查询语句后，会创建一个 Read View，**后续的查询语句利用这个 Read View，通过这个 Read View就可以在 undo log 版本链找到事务开始时的数据，所以事务过程中每次查询的数据都是一样**，即使中途有其他事务插入了新纪录，是查询不出来这条数据的，所以就很好了避免幻读问题。

##### 当前读是如何避免幻读的？、

​		MySQL 里除了普通查询是快照读，其他都是**当前读**，比如 update、insert、delete，这些语句执行前都会查询最新版本的数据，然后再做进一步的操作。

![1736256634098](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736256634098.png)

### 锁

#### 全局锁

​		全局锁主要应用于做**全库逻辑备份**，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。

​		加上全局锁，意味着整个数据库都是只读状态。

​		那么如果数据库里有很多数据，备份就会花费很多的时间，关键是备份期间，业务只能读数据，而不能更新数据，这样会造成业务停滞。

![1736333104657](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736333104657.png)

#### 表级锁

###### 表锁

```mysql
# 表级别的共享锁，也就是读锁；
# 允许当前会话读取被锁定的表，但阻止其他会话对这些表进行写操作。本线程不能访问其他表
lock tables t_student read;

# 表级别的独占锁，也就是写锁
# 允许当前会话对表进行读写操作，但阻止其他会话对这些表进行任何操作（读或写）
lock tables t_stuent write;
```

###### 元数据锁

​		不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：

​		对一张表进行 CRUD 操作时，加的是 **MDL 读锁**；

​		对一张表做结构变更操作的时候，加的是 **MDL 写锁**；

​		MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。

​		当有线程在执行 select 语句（ 加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（ 申请 MDL 写锁），那么将会被阻塞，直到执行完 select 语句（ 释放 MDL 读锁）。 反之，也一样

​		MDL 是在事务提交后才会释放，这意味着**事务执行期间，MDL 是一直持有的**。

###### 意向锁

​	在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；

​	在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；

```mysql
# 先在表上加上意向共享锁，然后对读取的记录加共享锁
select ... lock in share mode;
# 先表上加上意向独占锁，然后对读取的记录加独占锁
select ... for update;
```

​		意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突。

​		**表锁和行锁是满足读读共享、读写互斥、写写互斥的。意向锁的目的是为了快速判断表里是否有记录被加锁**。

###### AUTO-INC 锁

​		AUTO-INC 锁是特殊的表锁机制，锁**不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放**。

​		**在插入数据时，会加一个表级别的 AUTO-INC 锁**，然后为被 `AUTO_INCREMENT` 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。

​		那么，一个事务在持有 AUTO-INC 锁的过程中，其他事务的如果要向该表插入语句都会被阻塞，从而保证插入数据时，被 `AUTO_INCREMENT` 修饰的字段的值是连续递增的。

​		 **在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种轻量级的锁来实现自增。**

#### 行级锁

​			InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁。

​			普通的 select 语句是不会对记录加锁的，因为它属于快照读。如果要在查询时对记录加行锁，可以使用下面这两个方式，这种查询会加锁的语句称为**锁定读**。

​			共享锁（S锁）满足读读共享，读写互斥。独占锁（X锁）满足写写互斥、读写互斥。

![1736335021722](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736335021722.png)

###### Record Lock

​		记录锁，也就是仅仅把一条记录锁上；记录锁是有 S 锁和 X 锁之分的：

​		当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;

​		当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。

###### Gap Lock

​		间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。

![1736335164172](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736335164172.png)

间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别, 间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的。

###### Next-Key Lock

​		临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。

![1736335233899](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736335233899.png)

​		next-key lock 即能保护该记录，又能阻止其他事务将新纪录插入到被保护记录前面的间隙中。

​		**next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的**。

###### 插入意向锁

​		一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。

​		如果有的话，插入操作就会发生**阻塞**，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个**插入意向锁**，表明有事务想在某个区间插入新记录，但是现在处于等待状态。

![1736335395514](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736335395514.png)

插入意向锁名字虽然有意向锁，但是它并**不是意向锁，它是一种特殊的间隙锁，属于行级别锁**。

#### MySQL 是怎么加行锁的？

​		普通的 select 语句是不会对记录加锁的（除了串行化隔离级别），因为它属于快照读，是通过 MVCC（多版本并发控制）实现的。

​		**update 和 delete 操作都会加行级锁，且锁的类型都是独占锁(X型锁)**。

​		**加锁的对象是索引，加锁的基本单位是 next-key lock**     它是由记录锁和间隙锁组合而成的，**next-key lock 是前开后闭区间，而间隙锁是前开后开区间**。

###### 唯一索引等值查询

![1736336118429](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736336118429.png)

![1736336236142](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736336236142.png)

###### 唯一索引范围查询

​		当唯一索引进行范围查询时，会对每一个扫描到的索引加 next-key 锁，然后如果遇到下面这些情况，会退化成记录锁或者间隙锁：

![1736336513367](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736336513367.png)

###### 非唯一索引等值查询

​		当我们用非唯一索引进行等值查询的时候，因为存在两个索引，一个是主键索引，一个是非唯一索引（二级索引），所以在加锁时，**同时会对这两个索引都加锁**，但是对主键索引加锁的时候，**只有满足查询条件的记录才会对它们的主键索引加锁**。

![1736336821853](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736336821853.png)

###### 非唯一索引范围查询

​		非唯一索引和主键索引的范围查询的加锁也有所不同，不同之处在于**非唯一索引范围查询，索引的 next-key lock 不会有退化为间隙锁和记录锁的情况**，也就是非唯一索引进行范围查询时，对二级索引记录加锁都是加 next-key 锁。

​		**对记录加锁带基本单位是 next-key 锁，但是会因为一些条件会退化成间隙锁，或者记录锁。**

##### 死锁

​		可重复读隔离级别下，是存在幻读的问题。

​		**Innodb 引擎为了解决「可重复读」隔离级别下的幻读问题就引出了 next-key 锁**，它是记录锁和间隙锁的组合。

![1736337568526](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736337568526.png)

![1736337576278](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736337576278.png)

### 日志

#### undo log

​		是 Innodb 存储引擎层生成的日志，实现了事务中的**原子性**，主要**用于事务回滚和 MVCC**。

​		我们在执行执行一条“增删改”语句的时候，虽然没有输入 begin 开启事务和 commit 提交事务，但是 MySQL 会**隐式开启事务**来执行“增删改”语句的，执行完就自动提交事务的，这样就保证了执行完“增删改”语句后，我们可以及时在数据库表看到“增删改”的结果了。

​		undo log 是一种用于撤销回退的日志。在事务没提交之前，MySQL 会先记录更新前的数据到 undo log 日志文件里面，当事务回滚时，可以利用 undo log 来进行回滚。

![1736338222303](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736338222303.png)



​		在**插入**一条记录时，要把这条记录的主键值记下来，这样之后回滚时只需要把这个主键值对应的记录**删掉**就好了；

​		在**删除**一条记录时，要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录**插入**到表中就好了；

​		在**更新**一条记录时，要把被更新的列的旧值记下来，这样之后回滚时再把这些列**更新为旧值**就好了。

**针对 delete 操作和 update 操作会有一些特殊的处理：**

​		delete操作实际上不会立即直接删除，而是将delete对象打上delete flag，标记为删除，最终的删除操作是purge线程完成的。

​		update分为两种情况：update的列是否是主键列。

​				如果不是主键列，在undo log中直接反向记录是如何update的。即update是直接进行的。

​				如果是主键列，update分两部执行：先删除该行，再插入一行目标行。

一条记录的每一次更新操作产生的 undo log 格式都有一个 roll_pointer指针和一个 trx_id 事务id：

​		通过 trx_id 可以知道该记录是被哪个事务修改的；

​		通过 roll_pointer 指针可以将这些 undo log串成一个链表，这个链表就被称为版本链；

![1736338433132](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736338433132.png)

**undo log 还有一个作用，通过 ReadView +** **undo log 实现 MVCC（多版本并发控制）**。

undo log 两大作用：

​		**实现事务回滚，保障事务的原子性**。事务处理过程中，如果出现了错误或者用户执 行了ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。

​		**实现 MVCC（多版本并发控制）关键因素之一**。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。

#### redo log

​		Buffer Pool 是提高了读写效率没错，但是问题来了，Buffer Pool 是基于内存的，而内存总是不可靠，万一断电重启，还没来得及落盘的脏页数据就会丢失。

​		为了防止断电导致数据丢失的问题，当有一条记录需要更新的时候，InnoDB 引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录下来，**这个时候更新就算完成了**。

​		后续，InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就是 **WAL （Write-Ahead Logging）技术**。

​		**WAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上**。

![1736339170296](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736339170296.png)

​		redo log 是物理日志，记录了某个数据页做了什么修改，比如**对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新**，每当执行一个事务就会产生这样的一条或者多条物理日志。事务提交时，只要先将 redo log 持久化到磁盘即可。当系统崩溃时，虽然脏页数据没有持久化，但是 redo log 已经持久化，接着 MySQL 重启后，可以根据 redo log 的内容，将所有数据恢复到最新的状态。

​		**在内存修改该 Undo 页面后，也是需要记录对应的 redo log，因为undo log也要实现持久性的保护**。

###### redo log 和 undo log 区别

![1736339338076](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736339338076.png)

![1736339387251](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736339387251.png)

![1736339425694](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736339425694.png)

![1736339475626](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736339475626.png)

![1736339490061](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736339490061.png)

![1736339505821](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736339505821.png)

###### redo log 文件写满了怎么办

​	![1736339681977](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736339681977.png)

![1736339702770](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736339702770.png)



#### binlog 

​		MySQL 在完成一条更新操作后，Server 层还会生成一条 binlog，等之后事务提交的时候，会将该事物执行过程中产生的所有 binlog 统一写 入 binlog 文件。

​		binlog 文件是记录了所有数据库表结构变更和表数据修改的日志，不会记录查询类的操作，比如 SELECT 和 SHOW 操作。

###### redo log 和 binlog 有什么区别

​		![1736339981246](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736339981246.png)

![1736339989200](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736339989200.png)

![1736340002655](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736340002655.png)

##### 主从复制是怎么实现？

​		MySQL 的主从复制依赖于 binlog ，也就是记录 MySQL 上的所有变化并以二进制形式保存在磁盘上。复制的过程就是将 binlog 中的数据从主库传输到从库上。

![1736340157361](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736340157361.png)

**MySQL 集群的主从复制过程梳理成 3 个阶段**

​		写入Binlog：主库写 binlog 日志，提交事务，并更新本地存储数据。

​		同步Binlog：把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中。

​		回放Binlog：回放 binlog，并更新存储引擎中的数据。

![1736340242126](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736340242126.png)

​	在完成主从复制之后，你就可以在写数据时只写主库，在读数据时只读从库，这样即使写请求会锁表或者锁记录，也不会影响读请求的执行。

![1736340314371](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736340314371.png)

![1736340385173](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736340385173.png)

##### binlog 什么时候刷盘？

​			事务执行过程中，先把日志写到 binlog cache（Server 层的 cache），事务提交的时候，再把 binlog cache 写到 binlog 文件中。

![1736340552382](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736340552382.png)

![1736340568355](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736340568355.png)

### Buffer Pool

![1736338784129](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736338784129.png)

​		![1736338797683](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736338797683.png)

有了 Buffer Poo 后：

​		当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。

​		当修改数据时，如果数据存在于 Buffer Pool 中，那直接修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页（该页的内存数据和磁盘上的数据已经不一致）, 为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。

​		![1736338992306](C:\Users\renyu\AppData\Roaming\Typora\typora-user-images\1736338992306.png)

**Undo 页是记录什么？**

​		开启事务后，InnoDB 层更新记录前，首先要记录相应的 undo log，如果是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入Buffer Pool 中的 Undo 页面。

​		当我们查询一条记录时，InnoDB 是会把整个页的数据加载到 Buffer Pool 中，将页加载到 Buffer Pool 后，再通过页里的「页目录」去定位到某条具体的记录。